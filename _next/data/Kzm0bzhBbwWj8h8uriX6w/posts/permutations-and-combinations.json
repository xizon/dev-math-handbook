{"pageProps":{"currentData":{"slug":"permutations-and-combinations","title":"排列组合","scope":"<div><div>排列组合是学生时代常见的数学基础理论，在计算机领域，他们也属于离散数学。</div><div>广义的组合数学（英语：Combinatorics）就是离散数学，狭义的组合数学是组合计数、图论、代数结构、数理逻辑等的总称。</div><div>在组合数学中，排列一词的传统意义是一个有序序列，其中元素不重复，但可能有阙漏。例如1,2,4,3可以称为1,2,3,4,5,6的一个排列，但是其中不含5,6。此时通常会标明为“从n个对象取r个对象的排列”。</div><div>学习离散数学的过程中，[计数] 对于排列组合是一个很有趣的研究方向。</div><div>&nbsp;&nbsp;• 排列：与元素的次序有关。</div><div>&nbsp;&nbsp;• 组合：与元素的次序无关。</div></div>","formula":"■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n阶乘函数（符号：!）\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n表示将一系列递减的自然数相乘。 例子：\n\n4! = 4 × 3 × 2 × 1 = 24\n7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5,040\n1! = 1\n\n\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n排列的计数\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n▶ 设 A 是有 n 个元素的集合，则有 2^n 个子集\n▶ 如果 1 ≤ r ≤ n, 那么 n 个对象中每次取 r 个的排列数是 n • (n-1) • (n-2) •...• (n-r+1)\n▶ 设 A 是 {a,b,c}， A 的可能排列为 3! = 3 × 2 × 1 = 6 种\n▶ 简化公式(排列公式)为：\n\nnPr = n! ÷ (n-r)!\n\n\n▶ 在一个有n个对象的集合中，第 1 个对象出现 k[1] 次，第 2 个对象出现 k[2] 次，则该集合所形成的不同排列数为\n\nn! ÷ ( k[1]! • k[2]! •...• k[t]! )  (其中 k[1] + k[2] + ... + k[t] = n)\n\n\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n组合的计数\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n▶ 设 A = {1,2,3,4}, 每次取三个时，A 的不同组合可以是： \nA[1] = {2,3,4} = {2,3,1} = {1,3,2} = {3,1,2} = {3,2,1}\nA[2] = {1,2,4} = {2,4,1} = {1,4,2} = {4,1,2} = {4,2,1}\nA[3] = ...\n\n▶ 设 A 是一个集合且  |A| = n, 0 ≤ r ≤ n, 那么每次取 r 个时 A 的元素的组合数为：\n\nnCr = n! ÷ [ r! • (n-r)! ]\n\n每次取 r 个时，A 的组合数不依赖于 A。\n\n\n▶ 例子：从一副 52 张纸牌中分发 5 张，则有 51! ÷ (5!47!) = 2598960 种组合方法\n\n\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n鸽巢原理(存在性证明)\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n如果你学过离散数学，就会学到这个原理的证明。如果 n 只鸽子被分配到 m 个鸽巢里，且 m &lt; n， 那么至少有 1 个鸽巢含有 2 只或者更多只鸽子。\n\n\n\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n概率基础\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n样本空间 ( 硬币正反面作为样本排列： A = {HH, HT, TH, TT} )\n对事件赋予概率\n“等可能” 的结果\n\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n递归关系\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n比如斐波那契数列","preview":"data:image/png;base64,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","solution":{"javascript":{"code":"/**\n * 元素的排列方式\n * @param {Array} items  - 需要组合的元素，使用数组表示\n * @returns {Array} 所有组合的数组集合\n */\nexport function permutations(items) {\n\n    const results = [];\n\n    /* 递归组合 */\n    function permute(arr, memo = []) {\n        let currentArr;\n\n        for (let i = 0; i &lt; arr.length; i++) {\n\n            /* 每次以被删除的元素作为数组初始值 */\n            currentArr = arr.splice(i, 1);\n            if (arr.length === 0) {\n                results.push(memo.concat(currentArr));\n            }\n\n            /* 克隆一个被删除元素后的新数组, 直接将 arr 结果传入 permute() 函数也是可以的 */\n            const arrRes = arr.slice();\n            permute(arrRes, memo.concat(currentArr));\n\n            /* 注意：splice后的数组，会覆盖原来的数组，造成for或者forEach循环的次数减少, 因此我们要将删除的元素重新push进去 */\n            arr.splice(i, 0, currentArr[0]);\n        }\n\n        return results;\n    }\n\n    permute(items);\n\n    return results;\n}\n\n\n\n/**\n * 元素的组合方式(取出元素没有考虑重复性)\n * @param {Array} arr - 输入数组\n * @param {Number} quantity - 要取出的元素数量(用来组合)\n * @param {Number} index - arr 中的当前索引\n * @param {Array} tempArr - 临时数组\n * @param {Number} tempArrIndex - tempArr 中的当前索引\n * @param {Array} result -  存储每次分组后的结果\n * @returns {Array} 所有组合的数组集合\n */\nfunction combinationUtil(arr, quantity, index, tempArr, tempArrIndex, result) {\n\n    const { length } = arr;\n\n    /* 打印每组的结果 */\n    if (index == quantity) {\n        const res = [];\n        for (let j = 0; j &lt; quantity; j++) {\n            res.push(tempArr[j]);\n        }\n        result.push(res);\n        return;\n    }\n\n    /* 当没有更多元素可以放入 tempArr 时 */\n    if (tempArrIndex &gt;= length) {\n        return;\n    }\n\n\n    /* 包含当前元素，原数组向下移位 */\n    tempArr[index] = arr[tempArrIndex];\n    combinationUtil(arr, quantity, index + 1, tempArr, tempArrIndex + 1, result);\n\n    /* 排除当前元素，临时数组向下移位 */\n    combinationUtil(arr, quantity, index, tempArr, tempArrIndex + 1, result);\n\n    return result;\n}\n\nexport function combinations(arr, quantity) {\n    const tempArr = new Array(quantity);\n\n    return combinationUtil(arr, quantity, 0, tempArr, 0, []);\n}","test":"import { permutations, combinations } from './index';\n\n\n/* 排列 [1, 2, 3] 这3个元素，它们有多少种排列方法(它们是排列是有序的) */\nconsole.log(permutations([1, 2, 3]));\n/* 输出\n[\n    [1,2,3],\n    [1,3,2],\n    [2,1,3],\n    [2,3,1],\n    [3,1,2],\n    [3,2,1]\n]\n*/\n\n\n\n/* [1, 2, 3, 4]四个元素取出2个，它们的组合为 */\nconsole.log(combinations([1, 2, 3, 4], 2));\n/* 输出：\n[\n[1, 2], \n[1, 3], \n[1, 4], \n[2, 3], \n[2, 4], \n[3, 4]\n]\n*/\n"}}}},"__N_SSG":true}